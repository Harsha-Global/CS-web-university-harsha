using System.Threading;

class Shared
{
  public static int[] Data { get; set; } //Store data values generated by producer thread
  public static int BatchCount { get;set; } //Total number of values
  public static int BatchSize { get; set; }
  public static AutoResetEvent Event { get; set; }

  static Shared()
  {
    Data = new int[15];
    BatchCount = 5;
    BatchSize = 3;
    Event = new AutoResetEvent(false); //unsignaled (false)
  }
}

//Represents producer thread
class Producer
{
  public void Produce()
  {
    Console.WriteLine($"{Thread.CurrentThread.Name} started");

    for (int i = 0; i < Shared.BatchCount; i++) //5 times
    {
      //Generate some data and store it in the Data array
      for (int j = 0; j < Shared.BatchSize; j++) //3 times
      {
        Shared.Data[i * Shared.BatchSize + j] = (i * Shared.BatchSize) + j + 1; //1 to 15
        Thread.Sleep(300); //simular artificial latency (delay)
      }

      //Set the signal (signal that the producer has finished generating data)
      Shared.Event.Set();
      //AutoResetEvent allows one waiting thread to proceed; and immediatly resets the event to "unsignaled". So an explicit reset is not required

      //Reset the signal (makes the consumer thread wait for signal before reading next batch)
      //Shared.Event.Reset();
    }
    

    Console.WriteLine($"{Thread.CurrentThread.Name} completed");
  }
}


//Represents consumer thread
class Consumer
{
  public void Consume()
  {
    Console.WriteLine($"{Thread.CurrentThread.Name} started");
    Console.WriteLine("Consumer is waiting for producer thread to finish generating data");

    for (int i = 0; i < Shared.BatchCount; i++)
    {
      Shared.Event.WaitOne(); //consumer thread waits until the status of event becomes signaled
      Console.WriteLine("Consumer has received a signal from the Producer");

      //read data
      Console.WriteLine("\nData is");
      for (int j = 0;j < Shared.BatchSize; j++)
      {
        Console.WriteLine(Shared.Data[i * Shared.BatchSize + j]);
      }
    }
    

    Console.WriteLine($"{Thread.CurrentThread.Name} completed");
  }
}


class Program
{
  static void Main()
  {
    //create objects of Producer and Consumer classes
    Producer producer = new Producer();
    Consumer consumer = new Consumer();

    //create delegate objects of ThreadStart
    ThreadStart threadStart1 = new ThreadStart(producer.Produce);
    ThreadStart threadStart2 = new ThreadStart(consumer.Consume);

    //create thread objects
    Thread producerThread = new Thread(threadStart1) {  Name = "Producer Thread" };
    Thread consumerThread = new Thread(threadStart2) {  Name = "Consumer Thread" };

    //Start threads
    producerThread.Start();
    consumerThread.Start();

    //Join both threads to main thread
    producerThread.Join();
    consumerThread.Join();

    Console.ReadKey();
  }
}